import numpy
import torch
import random
import sys
import warnings

from sklearn.ensemble import GradientBoostingRegressor, RandomForestClassifier
from exploiting_gradient import exploit_gradient
from technique_type import TechniqueType
from dataset.selector_dataset import SelectorDataset
from dataset.fake_human.cifar10_fake_human_dataset import Cifar10FakeHumanDataset
from dataset.fake_human.melanoma_fake_human_dataset import MelanomaFakeHumanDataset
from neural_network.convolutional_neural_network import ConvolutionalNeuralNetwork
from support import cprint, Color, parse_bool
from vae.vae import VAE
from neural_network.convolutional_melanoma_neural_network import ConvolutionalMelanomaNeuralNetwork

warnings.filterwarnings("ignore", category=UserWarning)


if len(sys.argv) != 10 or sys.argv[1] == "help":
    cprint("Usage:\n\t-parameter 1: quantity samples to select\n\t-parameter 2: training epochs\n\t-parameter 3: active epochs\n\t-parameter 4: reproducibility\n\t-parameter 5: use features\n\t-parameter 6: resume\n\t-parameter 7: limit samples\n\t-parameter 8: debug\n\t-parameter 9: technique \n\t\t1 for SCORE SINGLE DISTANCE\n\t\t2 for SCORE OTHER DISTANCE\n\t\t3 for CLASS SINGLE DISTANCE\n\t\t4 for CLASS OTHER DISTANCE\n\t\t5 for RANDOM\n\t\t6 for LEAST CONFIDENCE (UNCERTAINTY SAMPLING)\n", Color.RED)
    sys.exit(0)

# setting device
device = "cuda" if torch.cuda.is_available() else "cpu"
cprint("Running on {}...".format(device), Color.BLUE)

# setting reproducibility
reproducibility = parse_bool(sys.argv[4])
if reproducibility:
    torch.manual_seed(0)
    numpy.random.seed(0)
    random.seed(0)

# defining technique
technique_index = int(sys.argv[9])
if technique_index == 1:
    selector_technique_type = TechniqueType.SCORE_SINGLE_DISTANCE

elif technique_index == 2:
    selector_technique_type = TechniqueType.SCORE_OTHER_DISTANCE

elif technique_index == 3:
    selector_technique_type = TechniqueType.CLASS_SINGLE_DISTANCE

elif technique_index == 4:
    selector_technique_type = TechniqueType.CLASS_OTHER_DISTANCE

elif technique_index == 5:
    selector_technique_type = TechniqueType.RANDOM

elif technique_index == 6:
    selector_technique_type = TechniqueType.LEAST_CONFIDENCE

else:
    cprint("Unknown technique!", Color.RED)
    sys.exit(0)

# other settings
resume = parse_bool(sys.argv[6])
limit_samples = int(sys.argv[7])
debug = parse_bool(sys.argv[8])

# defining fixed parameters
if debug:
    training_set_size = 10
    test_set_size = 4

else:
    training_set_size = 10000
    test_set_size = 900

training_epochs = int(sys.argv[2])
active_epochs = int(sys.argv[3])
quantity_samples_to_select = int(sys.argv[1])
use_features = parse_bool(sys.argv[5])

# defining base parameters (neural network)
if debug:
    batch_size = 2

else:
    batch_size = 4

input_size = 512 * 512 * 3
output_size = 1

# iterating in order to do all tests
for i in range(9, 10): #TODO
    # defining current percentages
    percentage_labeled_samples = 1 - i * (0.1)
    percentage_unlabeled_samples = i * (0.1)

    # defining base parameters (sizes)
    total_labeled_samples_size = int((training_set_size - test_set_size) * percentage_labeled_samples)
    total_unlabeled_samples_size = int((training_set_size - test_set_size) * percentage_unlabeled_samples)

    # defining model (for selection samples)
    if selector_technique_type == TechniqueType.SCORE_SINGLE_DISTANCE or selector_technique_type == TechniqueType.SCORE_OTHER_DISTANCE:
        model = GradientBoostingRegressor(loss="lad", n_estimators=200)

    else:
        model = RandomForestClassifier(max_depth=5)
    #use_features = parse_bool(sys.argv[5]) #set use_features to False and avoid using the VAE altogether
    if use_features:
        features_extractor = VAE(device, "VAE melanoma", 512, 3, 7, 10)

    else:
        features_extractor = None

    # defining Neural Network and related things
    #neural_network = TestNeuralNetwork(input_size, output_size)
    neural_network = ConvolutionalNeuralNetwork(device)
    #neural_network = ConvolutionalMelanomaNeuralNetwork(device)
    #neural_network.criterion = torch.nn.MSELoss(reduction="sum")
    neural_network.criterion = torch.nn.CrossEntropyLoss()
    #neural_network.criterion = torch.nn.MSELoss()
    neural_network.optimizer = torch.optim.SGD(neural_network.parameters(), lr=1e-4)
    #neural_network.optimizer = torch.optim.Adam(neural_network.parameters(), lr=1e-4, weight_decay=5e-4)

    # defining nn's dataset with simulated annotator
    #dataset_fake_human = TestFakeHumanDataset(None, None, total_labeled_samples_size, total_unlabeled_samples_size, input_size, output_size, metric_size, batch_size)
    dataset_fake_human = Cifar10FakeHumanDataset(None, None, total_labeled_samples_size, total_unlabeled_samples_size, batch_size)
    #dataset_fake_human = MelanomaFakeHumanDataset(total_labeled_samples_size, total_unlabeled_samples_size, test_set_size, batch_size)

    # defining selector's dataset to build
    classed = selector_technique_type == TechniqueType.CLASS_SINGLE_DISTANCE or selector_technique_type == TechniqueType.CLASS_OTHER_DISTANCE
    dataset_selector = SelectorDataset(input_size, classed)

    # loading training
    start_loss, start_accuracy, end_loss, end_accuracy, elapsed_time = exploit_gradient(selector_technique_type, quantity_samples_to_select, training_epochs, active_epochs, model, neural_network, dataset_fake_human, dataset_selector, resume, limit_samples, features_extractor)
    cprint("Split used: {}% labeled and {}% unlabeled on {} samples".format(percentage_labeled_samples*100, percentage_unlabeled_samples*100, training_set_size), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Used technique: {}".format(selector_technique_type), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Active Learning training time: {}".format(elapsed_time), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Loss after first training: {}".format(start_loss), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Loss after exploiting gradient: {}".format(end_loss), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Accuracy after first training: {}".format(start_accuracy), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Accuracy after exploiting gradient: {}".format(end_accuracy), Color.LIGHT_MAGENTA, loggable = True)
    cprint("Saving neural network...", Color.GREEN)
    neural_network.save("./data/networks/cnn_{}_{}_{}.net".format(selector_technique_type, percentage_labeled_samples, percentage_unlabeled_samples))

cprint("Completed!", Color.YELLOW)
